from IPython.display import display, HTML

canvas_code = """
<style>
  #output{
    font-size: 48px;
    font-weight: 800;
    margin: 12px 0 0;
    letter-spacing: .5px;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  }
</style>

<canvas id="canvas" width="500" height="500" style="border:1px solid black;"></canvas><br>
<button onclick="clearCanvas()">クリア</button>
<p id="output"></p>

<script>
let canvas = document.getElementById("canvas");
let ctx = canvas.getContext("2d");
let drawing = false;
let strokes = [];
let currentStroke = [];

canvas.addEventListener("mousedown", (e) => {
  drawing = true;
  currentStroke = [];
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  ctx.beginPath();
  ctx.moveTo(x, y);
  currentStroke.push([x, y]);
});

canvas.addEventListener("mouseup", () => {
  drawing = false;
  if (currentStroke.length > 0) {
    strokes.push(currentStroke);
    currentStroke = [];
  }

  google.colab.kernel.invokeFunction('classify_strokes', [strokes], {})
    .then((result) => {
      const text = (result && result.data && result.data['text/plain']) || '';
      document.getElementById("output").innerText = text || '（結果なし）';
    });
});

canvas.addEventListener("mousemove", (e) => {
  if (!drawing) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  ctx.lineWidth = 6;
  ctx.lineCap = "round";
  ctx.strokeStyle = "black";

  ctx.lineTo(x, y);
  ctx.stroke();

  currentStroke.push([x, y]);
});

function clearCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  strokes = [];
  currentStroke = [];
  document.getElementById("output").innerText = "";
}
</script>
"""
display(HTML(canvas_code))


import os
import numpy as np
from google.colab import output
import tensorflow as tf

# 学習済みモデル読み込み
model = tf.keras.models.load_model("/content/qd_apparel_model.keras")
print("学習済みモデルをロードしました。")

class_names = ["straight","skinny","wide","frea","jogger"]
MAXLEN = 500

def points_to_xy(strokes_pts):
    xy_strokes = []
    for stroke in strokes_pts:
        if not stroke:
            continue

        x_list, y_list = [], []
        # 各ストローク内の点を一つずつ
        for point in stroke:
            x = float(point[0])
            y = float(point[1])
            x_list.append(x)
            y_list.append(y)
        # xとyのリストを1つのストロークとしてまとめる
        xy_strokes.append([x_list, y_list])
    return xy_strokes

def simplified(strokes):
  x_list = []
  y_list = []
  for stroke in strokes:
    x_list += stroke[0]
    y_list += stroke[1]

  min_x, min_y = min(x_list), min(y_list)
  max_x, max_y = max(x_list), max(y_list)
  w = max_x - min_x
  h = max_y - min_y
  s = max(w,h)
  scale = 255.0 / s

  out = []# それぞれのストロークを順番に処理
  for stroke in strokes:
    x_list = []
    y_list = []

    # 座標を左上に寄せて、255の範囲にそろえる
    for i in range(len(stroke[0])):
        x = (stroke[0][i] - min_x) * scale
        y = (stroke[1][i] - min_y) * scale
        x_list.append(x)
        y_list.append(y)
    out.append([x_list, y_list])
  return out

# ストローク形式の描画データ(strokes)を系列データ(seq)に変換
def convert_strokes_to_seq(strokes):
    seq_5d = []
    prev_x, prev_y = 0, 0 #seq(前の点の座標)初期化
    for stroke in strokes: #[[x1, x2...], [y1, y2...]]の形
        x_list, y_list = stroke[0], stroke[1] #strokeを[x, y]の2つに分ける

        for i in range(len(x_list)):
            x, y = x_list[i], y_list[i] #現在の(x,y)座標を取得
            dx, dy = x - prev_x, y - prev_y #前の点との座標差分(Δx,Δy)

             #ペンの状態をone-hotで、
            pen = [1, 0, 0] #ペンを動かしている
            if i == len(x_list) - 1: #最後の点か判定(最終点->ペンを離す状態に切り替え)
                pen = [0, 1, 0]  #ペンを離す
            seq_5d.append([dx, dy] + pen) #差分とペン状態をまとめて1つのベクトルとしてseqに追加
            prev_x, prev_y = x, y #今の点を次の点に設定

    seq_5d.append([0, 0, 0, 0, 1])  #終了を示すトークン
    return seq_5d #完成した系列を返

def preprocess_strokes(raw_strokes, maxlen=MAXLEN):
    xy = points_to_xy(raw_strokes)
    xy_sim = simplified(xy)
    seq_5d = convert_strokes_to_seq(xy_sim)

    #パディング
    if len(seq_5d) < MAXLEN:
      seq_5d += [[0.0]*5]*(MAXLEN - len(seq_5d))
    else:
      seq_5d = seq_5d[:MAXLEN]

    x = np.array(seq_5d, dtype=np.float32)
    x = np.expand_dims(x, axis=0)
    return x

#推論JSから呼ばれる
def classify_strokes(js_strokes):
    if not js_strokes or not js_strokes[0]:
        return "スケッチしてください"

    x = preprocess_strokes(js_strokes, maxlen=MAXLEN)
    pred = model.predict(x, verbose=2)
    label_id = int(np.argmax(pred[0]))
    confidence = float(np.max(pred[0]))
    label = class_names[label_id]
    return f"判定: {label}    精度: {confidence:.1%}"

output.register_callback('classify_strokes', classify_strokes)
